import { Inject, Injectable, PLATFORM_ID, Optional } from '@angular/core';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { getRtlScrollAxisType } from '@angular/cdk/platform';
import { fromEvent, merge, of, Observable, Subject } from 'rxjs';
import { expand, finalize, take, takeUntil, takeWhile } from 'rxjs/operators';
import BezierEasing from 'bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
// @dynamic
export class SmoothScrollManager {
    constructor(_document, _platform, customDefaultOptions) {
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions, so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = {
            duration: 468,
            easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            },
            ...customDefaultOptions,
        };
    }
    get _w() {
        return this._document.defaultView;
    }
    /**
     * Timing method
     */
    get _now() {
        return this._w.performance?.now?.bind(this._w.performance) || Date.now;
    }
    /**
     * changes scroll position inside an element
     */
    _scrollElement(el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    }
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    _getElement(el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    }
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    _initSmoothScroll(el) {
        if (this._onGoingScrolls.has(el)) {
            this._onGoingScrolls.get(el).next();
        }
        return this._onGoingScrolls.set(el, new Subject()).get(el);
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    _isFinished(context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    }
    /**
     * Terminates an ongoing smooth scroll
     */
    _interrupted(el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    }
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    _destroy(el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    _step(context) {
        return new Observable((subscriber) => {
            let elapsed = (this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            requestAnimationFrame(() => subscriber.next(context));
        });
    }
    _applyScrollToOptions(el, options) {
        if (!options.duration) {
            this._scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        const destroyed = this._initSmoothScroll(el);
        const context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: options.duration,
            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
        };
        return new Promise(resolve => {
            // Scroll each step recursively
            of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();
        });
    }
    /**
     * Dismiss an ongoing scroll
     * @param el
     */
    dismissOngoingScroll(el) {
        this._onGoingScrolls.get(el)?.next();
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param customOptions specified the offsets to scroll to.
     */
    scrollTo(scrollable, customOptions) {
        if (isPlatformBrowser(this._platform)) {
            const el = this._getElement(scrollable);
            const isRtl = getComputedStyle(el).direction === 'rtl';
            const rtlScrollAxisType = getRtlScrollAxisType();
            const options = {
                ...this._defaultOptions,
                ...customOptions,
                ...{
                    // Rewrite start & end offsets as right or left offsets.
                    left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                    right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
                }
            };
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                options.top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== 0 /* RtlScrollAxisType.NORMAL */) {
                if (options.left != null) {
                    options.right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    options.left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
        return Promise.resolve();
    }
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(scrollable, target, customOptions = {}) {
        const scrollableEl = this._getElement(scrollable);
        const targetEl = this._getElement(target, scrollableEl);
        const options = {
            ...customOptions,
            ...{
                left: targetEl.offsetLeft + (customOptions.left || 0),
                top: targetEl.offsetTop + (customOptions.top || 0)
            }
        };
        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();
    }
}
SmoothScrollManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: SmoothScrollManager, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: SMOOTH_SCROLL_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
SmoothScrollManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.0", ngImport: i0, type: SmoothScrollManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [SMOOTH_SCROLL_OPTIONS]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctZ2FsbGVyeS9zcmMvbGliL3Ntb290aC1zY3JvbGwvc21vb3RoLXNjcm9sbC1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBYyxNQUFNLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEYsT0FBTyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzlELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsb0JBQW9CLEVBQXFCLE1BQU0sdUJBQXVCLENBQUM7QUFFaEYsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDN0UsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5RSxPQUFPLFlBQVksTUFBTSxlQUFlLENBQUM7QUFDekMsT0FBTyxFQUNMLHFCQUFxQixFQUt0QixNQUFNLHVCQUF1QixDQUFDOztBQUUvQixXQUFXO0FBSVgsTUFBTSxPQUFPLG1CQUFtQjtJQXNCOUIsWUFBc0MsU0FBbUIsRUFDaEIsU0FBaUIsRUFDSCxvQkFBMkM7UUFGNUQsY0FBUyxHQUFULFNBQVMsQ0FBVTtRQUNoQixjQUFTLEdBQVQsU0FBUyxDQUFRO1FBbEIxRCxvR0FBb0c7UUFDcEcsbUdBQW1HO1FBQ25HLG9HQUFvRztRQUNwRyxxREFBcUQ7UUFDN0Msb0JBQWUsR0FBRyxJQUFJLEdBQUcsRUFBOEIsQ0FBQztRQWdCOUQsSUFBSSxDQUFDLGVBQWUsR0FBRztZQUNyQixRQUFRLEVBQUUs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LFlBQVksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3hELE1BQU0sT0FBTyxHQUEwQjtZQUNyQyxHQUFHLGFBQWE7WUFDaEIsR0FBRztnQkFDRCxJQUFJLEVBQUUsUUFBUSxDQUFDLFVBQVUsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO2dCQUNyRCxHQUFHLEVBQUUsUUFBUSxDQUFDLFNBQVMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO2FBQ25EO1NBQ0YsQ0FBQztRQUNGLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzdFLENBQUM7O2dIQWhPVSxtQkFBbUIsa0JBc0JWLFFBQVEsYUFDUixXQUFXLGFBQ0MscUJBQXFCO29IQXhCMUMsbUJBQW1CLGNBRmxCLE1BQU07MkZBRVAsbUJBQW1CO2tCQUgvQixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQjs7MEJBdUJjLE1BQU07MkJBQUMsUUFBUTs7MEJBQ2YsTUFBTTsyQkFBQyxXQUFXOzswQkFDbEIsUUFBUTs7MEJBQUksTUFBTTsyQkFBQyxxQkFBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdGFibGUsIFBMQVRGT1JNX0lELCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRE9DVU1FTlQsIGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IGNvZXJjZUVsZW1lbnQgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgZ2V0UnRsU2Nyb2xsQXhpc1R5cGUsIFJ0bFNjcm9sbEF4aXNUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7IF9Cb3R0b20sIF9MZWZ0LCBfUmlnaHQsIF9Ub3AsIF9XaXRob3V0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBvZiwgT2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaWJlciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZXhwYW5kLCBmaW5hbGl6ZSwgdGFrZSwgdGFrZVVudGlsLCB0YWtlV2hpbGUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgQmV6aWVyRWFzaW5nIGZyb20gJ2Jlemllci1lYXNpbmcnO1xuaW1wb3J0IHtcbiAgU01PT1RIX1NDUk9MTF9PUFRJT05TLFxuICBTbW9vdGhTY3JvbGxFbGVtZW50LFxuICBTbW9vdGhTY3JvbGxTdGVwLFxuICBTbW9vdGhTY3JvbGxUb0VsZW1lbnRPcHRpb25zLFxuICBTbW9vdGhTY3JvbGxUb09wdGlvbnNcbn0gZnJvbSAnLi9zbW9vdGgtc2Nyb2xsLm1vZGVsJztcblxuLy8gQGR5bmFtaWNcbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFNtb290aFNjcm9sbE1hbmFnZXIge1xuXG4gIC8vIERlZmF1bHQgb3B0aW9uc1xuICBwcml2YXRlIHJlYWRvbmx5IF9kZWZhdWx0T3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zO1xuXG4gIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBvbmdvaW5nIFNtb290aFNjcm9sbCBmdW5jdGlvbnMsIHNvIHRoZXkgY2FuIGJlIGhhbmRsZWQgaW4gY2FzZSBvZiBkdXBsaWNhdGlvbi5cbiAgLy8gRWFjaCBzY3JvbGxlZCBlbGVtZW50IGdldHMgYSBkZXN0cm95ZXIgc3RyZWFtIHdoaWNoIGdldHMgZGVsZXRlZCBpbW1lZGlhdGVseSBhZnRlciBpdCBjb21wbGV0ZXMuXG4gIC8vIFB1cnBvc2U6IElmIHVzZXIgY2FsbGVkIGEgc2Nyb2xsIGZ1bmN0aW9uIGFnYWluIG9uIHRoZSBzYW1lIGVsZW1lbnQgYmVmb3JlIHRoZSBzY3JvbGxzIGNvbXBsZXRlcyxcbiAgLy8gaXQgY2FuY2VscyB0aGUgb25nb2luZyBzY3JvbGwgYW5kIHN0YXJ0cyBhIG5ldyBvbmVcbiAgcHJpdmF0ZSBfb25Hb2luZ1Njcm9sbHMgPSBuZXcgTWFwPEhUTUxFbGVtZW50LCBTdWJqZWN0PHZvaWQ+PigpO1xuXG4gIHByaXZhdGUgZ2V0IF93KCk6IFdpbmRvdyB7XG4gICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFRpbWluZyBtZXRob2RcbiAgICovXG4gIHByaXZhdGUgZ2V0IF9ub3coKTogKCkgPT4gbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdy5wZXJmb3JtYW5jZT8ubm93Py5iaW5kKHRoaXMuX3cucGVyZm9ybWFuY2UpIHx8IERhdGUubm93O1xuICB9XG5cbiAgY29uc3RydWN0b3IoQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IERvY3VtZW50LFxuICAgICAgICAgICAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIF9wbGF0Zm9ybTogb2JqZWN0LFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFNNT09USF9TQ1JPTExfT1BUSU9OUykgY3VzdG9tRGVmYXVsdE9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucykge1xuICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZHVyYXRpb246IDQ2OCxcbiAgICAgIGVhc2luZzoge1xuICAgICAgICB4MTogMC40MixcbiAgICAgICAgeTE6IDAsXG4gICAgICAgIHgyOiAwLjU4LFxuICAgICAgICB5MjogMVxuICAgICAgfSxcbiAgICAgIC4uLmN1c3RvbURlZmF1bHRPcHRpb25zLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogY2hhbmdlcyBzY3JvbGwgcG9zaXRpb24gaW5zaWRlIGFuIGVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgX3Njcm9sbEVsZW1lbnQoZWw6IEhUTUxFbGVtZW50LCB4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQge1xuICAgIGVsLnNjcm9sbExlZnQgPSB4O1xuICAgIGVsLnNjcm9sbFRvcCA9IHk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGdpdmVuIHBhcmFtZXRlciBvZiB0eXBlIEhUTUxFbGVtZW50LCBFbGVtZW50UmVmIG9yIHNlbGVjdG9yXG4gICAqL1xuICBwcml2YXRlIF9nZXRFbGVtZW50KGVsOiBIVE1MRWxlbWVudCB8IEVsZW1lbnRSZWYgfCBzdHJpbmcsIHBhcmVudD86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQge1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gKHBhcmVudCB8fCB0aGlzLl9kb2N1bWVudCkucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgfVxuICAgIHJldHVybiBjb2VyY2VFbGVtZW50PEhUTUxFbGVtZW50PihlbCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBkZXN0cm95ZXIgc3RyZWFtLCByZS1pbml0aWFsaXplcyBpdCBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIHNjcm9sbGVkXG4gICAqL1xuICBwcml2YXRlIF9pbml0U21vb3RoU2Nyb2xsKGVsOiBIVE1MRWxlbWVudCk6IFN1YmplY3Q8dm9pZD4ge1xuICAgIGlmICh0aGlzLl9vbkdvaW5nU2Nyb2xscy5oYXMoZWwpKSB7XG4gICAgICB0aGlzLl9vbkdvaW5nU2Nyb2xscy5nZXQoZWwpLm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29uR29pbmdTY3JvbGxzLnNldChlbCwgbmV3IFN1YmplY3Q8dm9pZD4oKSkuZ2V0KGVsKSE7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHNtb290aCBzY3JvbGwgaGFzIHJlYWNoZWQsIGNsZWFucyB1cCB0aGUgc21vb3RoIHNjcm9sbCBzdHJlYW0gYW5kIHJlc29sdmVzIGl0cyBwcm9taXNlXG4gICAqL1xuICBwcml2YXRlIF9pc0ZpbmlzaGVkKGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXAsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPiwgcmVzb2x2ZTogKCkgPT4gdm9pZCk6IGJvb2xlYW4ge1xuICAgIGlmIChjb250ZXh0LmN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY29udGV4dC5jdXJyZW50WSAhPT0gY29udGV4dC55KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGVzdHJveWVkLm5leHQoKTtcbiAgICByZXNvbHZlKCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlcm1pbmF0ZXMgYW4gb25nb2luZyBzbW9vdGggc2Nyb2xsXG4gICAqL1xuICBwcml2YXRlIF9pbnRlcnJ1cHRlZChlbDogSFRNTEVsZW1lbnQsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IE9ic2VydmFibGU8RXZlbnQgfCB2b2lkPiB7XG4gICAgcmV0dXJuIG1lcmdlKFxuICAgICAgZnJvbUV2ZW50KGVsLCAnd2hlZWwnLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSksXG4gICAgICBmcm9tRXZlbnQoZWwsICd0b3VjaG1vdmUnLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSksXG4gICAgICBkZXN0cm95ZWRcbiAgICApLnBpcGUodGFrZSgxKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgZGVzdHJveWVyIGZ1bmN0aW9uLCBydW5zIGlmIHRoZSBzbW9vdGggc2Nyb2xsIGhhcyBmaW5pc2hlZCBvciBpbnRlcnJ1cHRlZFxuICAgKi9cbiAgcHJpdmF0ZSBfZGVzdHJveShlbDogSFRNTEVsZW1lbnQsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IHZvaWQge1xuICAgIGRlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgIHRoaXMuX29uR29pbmdTY3JvbGxzLmRlbGV0ZShlbCk7XG4gIH1cblxuICAvKipcbiAgICogQSBmdW5jdGlvbiBjYWxsZWQgcmVjdXJzaXZlbHkgdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xuICAgKi9cbiAgcHJpdmF0ZSBfc3RlcChjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwKTogT2JzZXJ2YWJsZTxTbW9vdGhTY3JvbGxTdGVwPiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFNtb290aFNjcm9sbFN0ZXA+KSA9PiB7XG4gICAgICBsZXQgZWxhcHNlZCA9ICh0aGlzLl9ub3coKSAtIGNvbnRleHQuc3RhcnRUaW1lKSAvIGNvbnRleHQuZHVyYXRpb247XG5cbiAgICAgIC8vIGF2b2lkIGVsYXBzZWQgdGltZXMgaGlnaGVyIHRoYW4gb25lXG4gICAgICBlbGFwc2VkID0gZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcblxuICAgICAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxuICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0LmVhc2luZyhlbGFwc2VkKTtcblxuICAgICAgY29udGV4dC5jdXJyZW50WCA9IGNvbnRleHQuc3RhcnRYICsgKGNvbnRleHQueCAtIGNvbnRleHQuc3RhcnRYKSAqIHZhbHVlO1xuICAgICAgY29udGV4dC5jdXJyZW50WSA9IGNvbnRleHQuc3RhcnRZICsgKGNvbnRleHQueSAtIGNvbnRleHQuc3RhcnRZKSAqIHZhbHVlO1xuXG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50KGNvbnRleHQuc2Nyb2xsYWJsZSwgY29udGV4dC5jdXJyZW50WCwgY29udGV4dC5jdXJyZW50WSk7XG4gICAgICAvLyBQcm9jZWVkIHRvIHRoZSBzdGVwXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gc3Vic2NyaWJlci5uZXh0KGNvbnRleHQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX2FwcGx5U2Nyb2xsVG9PcHRpb25zKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFvcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50KGVsLCBvcHRpb25zLmxlZnQsIG9wdGlvbnMudG9wKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGEgZGVzdHJveWVyIHN0cmVhbSwgcmVpbml0aWFsaXplIGl0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgc2Nyb2xsZWRcbiAgICBjb25zdCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4gPSB0aGlzLl9pbml0U21vb3RoU2Nyb2xsKGVsKTtcblxuICAgIGNvbnN0IGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXAgPSB7XG4gICAgICBzY3JvbGxhYmxlOiBlbCxcbiAgICAgIHN0YXJ0VGltZTogdGhpcy5fbm93KCksXG4gICAgICBzdGFydFg6IGVsLnNjcm9sbExlZnQsXG4gICAgICBzdGFydFk6IGVsLnNjcm9sbFRvcCxcbiAgICAgIHg6IG9wdGlvbnMubGVmdCA9PSBudWxsID8gZWwuc2Nyb2xsTGVmdCA6IH5+b3B0aW9ucy5sZWZ0LFxuICAgICAgeTogb3B0aW9ucy50b3AgPT0gbnVsbCA/IGVsLnNjcm9sbFRvcCA6IH5+b3B0aW9ucy50b3AsXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgIGVhc2luZzogQmV6aWVyRWFzaW5nKG9wdGlvbnMuZWFzaW5nLngxLCBvcHRpb25zLmVhc2luZy55MSwgb3B0aW9ucy5lYXNpbmcueDIsIG9wdGlvbnMuZWFzaW5nLnkyKVxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAvLyBTY3JvbGwgZWFjaCBzdGVwIHJlY3Vyc2l2ZWx5XG4gICAgICBvZihudWxsKS5waXBlKFxuICAgICAgICBleHBhbmQoKCkgPT4gdGhpcy5fc3RlcChjb250ZXh0KS5waXBlKFxuICAgICAgICAgIHRha2VXaGlsZSgoY3VyckNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXApID0+IHRoaXMuX2lzRmluaXNoZWQoY3VyckNvbnRleHQsIGRlc3Ryb3llZCwgcmVzb2x2ZSkpXG4gICAgICAgICkpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5faW50ZXJydXB0ZWQoZWwsIGRlc3Ryb3llZCkpLFxuICAgICAgICBmaW5hbGl6ZSgoKSA9PiB0aGlzLl9kZXN0cm95KGVsLCBkZXN0cm95ZWQpKVxuICAgICAgKS5zdWJzY3JpYmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNtaXNzIGFuIG9uZ29pbmcgc2Nyb2xsXG4gICAqIEBwYXJhbSBlbFxuICAgKi9cbiAgZGlzbWlzc09uZ29pbmdTY3JvbGwoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5fb25Hb2luZ1Njcm9sbHMuZ2V0KGVsKT8ubmV4dCgpO1xuICB9XG5cblxuICAvKipcbiAgICogU2Nyb2xscyB0byB0aGUgc3BlY2lmaWVkIG9mZnNldHMuIFRoaXMgaXMgYSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2Nyb2xsVG9cbiAgICogbWV0aG9kLCBzaW5jZSBicm93c2VycyBhcmUgbm90IGNvbnNpc3RlbnQgYWJvdXQgd2hhdCBzY3JvbGxMZWZ0IG1lYW5zIGluIFJUTC4gRm9yIHRoaXMgbWV0aG9kXG4gICAqIGxlZnQgYW5kIHJpZ2h0IGFsd2F5cyByZWZlciB0byB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lciBpcnJlc3BlY3RpdmVcbiAgICogb2YgdGhlIGxheW91dCBkaXJlY3Rpb24uIHN0YXJ0IGFuZCBlbmQgcmVmZXIgdG8gbGVmdCBhbmQgcmlnaHQgaW4gYW4gTFRSIGNvbnRleHQgYW5kIHZpY2UtdmVyc2FcbiAgICogaW4gYW4gUlRMIGNvbnRleHQuXG4gICAqIEBwYXJhbSBzY3JvbGxhYmxlIGVsZW1lbnRcbiAgICogQHBhcmFtIGN1c3RvbU9wdGlvbnMgc3BlY2lmaWVkIHRoZSBvZmZzZXRzIHRvIHNjcm9sbCB0by5cbiAgICovXG4gIHNjcm9sbFRvKHNjcm9sbGFibGU6IFNtb290aFNjcm9sbEVsZW1lbnQsIGN1c3RvbU9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLl9wbGF0Zm9ybSkpIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5fZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcbiAgICAgIGNvbnN0IGlzUnRsID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgIGNvbnN0IHJ0bFNjcm9sbEF4aXNUeXBlID0gZ2V0UnRsU2Nyb2xsQXhpc1R5cGUoKTtcblxuICAgICAgY29uc3Qgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zID0ge1xuICAgICAgICAuLi4odGhpcy5fZGVmYXVsdE9wdGlvbnMgYXMgX1dpdGhvdXQ8X0JvdHRvbSAmIF9Ub3A+KSxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgLi4uKHtcbiAgICAgICAgICAvLyBSZXdyaXRlIHN0YXJ0ICYgZW5kIG9mZnNldHMgYXMgcmlnaHQgb3IgbGVmdCBvZmZzZXRzLlxuICAgICAgICAgIGxlZnQ6IGN1c3RvbU9wdGlvbnMubGVmdCA9PSBudWxsID8gKGlzUnRsID8gY3VzdG9tT3B0aW9ucy5lbmQgOiBjdXN0b21PcHRpb25zLnN0YXJ0KSA6IGN1c3RvbU9wdGlvbnMubGVmdCxcbiAgICAgICAgICByaWdodDogY3VzdG9tT3B0aW9ucy5yaWdodCA9PSBudWxsID8gKGlzUnRsID8gY3VzdG9tT3B0aW9ucy5zdGFydCA6IGN1c3RvbU9wdGlvbnMuZW5kKSA6IGN1c3RvbU9wdGlvbnMucmlnaHRcbiAgICAgICAgfSBhcyBfV2l0aG91dDxfQm90dG9tICYgX1RvcD4pXG4gICAgICB9O1xuXG4gICAgICAvLyBSZXdyaXRlIHRoZSBib3R0b20gb2Zmc2V0IGFzIGEgdG9wIG9mZnNldC5cbiAgICAgIGlmIChvcHRpb25zLmJvdHRvbSAhPSBudWxsKSB7XG4gICAgICAgIChvcHRpb25zIGFzIF9XaXRob3V0PF9Cb3R0b20+ICYgX1RvcCkudG9wID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0IC0gb3B0aW9ucy5ib3R0b207XG4gICAgICB9XG5cbiAgICAgIC8vIFJld3JpdGUgdGhlIHJpZ2h0IG9mZnNldCBhcyBhIGxlZnQgb2Zmc2V0LlxuICAgICAgaWYgKGlzUnRsICYmIHJ0bFNjcm9sbEF4aXNUeXBlICE9PSBSdGxTY3JvbGxBeGlzVHlwZS5OT1JNQUwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X0xlZnQ+ICYgX1JpZ2h0KS5yaWdodCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGggLSBvcHRpb25zLmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEKSB7XG4gICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5yaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCkge1xuICAgICAgICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHQgPyAtb3B0aW9ucy5yaWdodCA6IG9wdGlvbnMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfUmlnaHQ+ICYgX0xlZnQpLmxlZnQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gb3B0aW9ucy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2Nyb2xsVG9PcHRpb25zKGVsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjcm9sbCB0byBlbGVtZW50IGJ5IHJlZmVyZW5jZSBvciBzZWxlY3RvclxuICAgKi9cbiAgc2Nyb2xsVG9FbGVtZW50KHNjcm9sbGFibGU6IFNtb290aFNjcm9sbEVsZW1lbnQsIHRhcmdldDogU21vb3RoU2Nyb2xsRWxlbWVudCwgY3VzdG9tT3B0aW9uczogU21vb3RoU2Nyb2xsVG9FbGVtZW50T3B0aW9ucyA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc2Nyb2xsYWJsZUVsID0gdGhpcy5fZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcbiAgICBjb25zdCB0YXJnZXRFbCA9IHRoaXMuX2dldEVsZW1lbnQodGFyZ2V0LCBzY3JvbGxhYmxlRWwpO1xuICAgIGNvbnN0IG9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyA9IHtcbiAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgICAuLi57XG4gICAgICAgIGxlZnQ6IHRhcmdldEVsLm9mZnNldExlZnQgKyAoY3VzdG9tT3B0aW9ucy5sZWZ0IHx8IDApLFxuICAgICAgICB0b3A6IHRhcmdldEVsLm9mZnNldFRvcCArIChjdXN0b21PcHRpb25zLnRvcCB8fCAwKVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRhcmdldEVsID8gdGhpcy5zY3JvbGxUbyhzY3JvbGxhYmxlRWwsIG9wdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbiJdfQ==